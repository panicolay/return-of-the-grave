<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Song</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <a href="index.html">← Accueil</a>
    <h1 id="title"></h1>
    <div id="song"></div>
    <div id="popover" class="popover"></div>

    <script>
        const songId = new URLSearchParams(window.location.search).get("song");
        if (!songId) {
            document.getElementById("title").textContent = "Aucun morceau sélectionné";
        } else {
            fetch(`data/${songId}.json`)
                .then(res => res.json())
                .then(data => {
                    document.title = data.title;
                    document.getElementById("title").textContent = data.title;
                    render(data);
                });
        }

        function render(data) {
            // Find total duration across all instruments
            let totalDuration = 0;
            for (const instrument of data.instruments) {
                for (const p of instrument.patterns) {
                    const end = p.start + p.duration * p.repeat;
                    if (end > totalDuration) totalDuration = end;
                }
            }
            if (totalDuration === 0) return;

            // Detect if we're in desktop mode (horizontal layout)
            const isDesktop = window.innerWidth >= 800;
            const songEl = document.getElementById("song");

            let pxPerUnit;
            if (isDesktop) {
                // Horizontal mode: use available width
                const availableWidth = window.innerWidth - 48 - 100 - 16; // padding + label + gap
                pxPerUnit = availableWidth / totalDuration;
            } else {
                // Vertical mode: use available height
                const availableHeight = window.innerHeight - songEl.getBoundingClientRect().top - 24;
                pxPerUnit = availableHeight / totalDuration;
            }

            const songDiv = document.createElement("div");
            songDiv.className = "song";

            for (const instrument of data.instruments) {
                const col = document.createElement("div");
                col.className = "instrument";

                const name = document.createElement("div");
                name.className = "instrument-name";
                name.textContent = instrument.name;
                col.appendChild(name);

                const patternsDiv = document.createElement("div");
                patternsDiv.className = "patterns";

                const events = [];

                // Check if using new format (patternDefinitions + timeline) or old format (patterns)
                if (instrument.patternDefinitions && instrument.timeline) {
                    // New format: build a map of pattern definitions
                    const patternMap = {};
                    for (const pDef of instrument.patternDefinitions) {
                        patternMap[pDef.id] = pDef;
                    }

                    // Process timeline entries
                    for (const tEntry of instrument.timeline) {
                        const pDef = patternMap[tEntry.patternId];
                        if (!pDef) continue; // Skip if pattern not found

                        // Use timeline duration if provided, otherwise use pattern definition duration
                        const duration = tEntry.duration !== undefined ? tEntry.duration : pDef.duration;

                        for (let i = 0; i < tEntry.repeat; i++) {
                            events.push({
                                start: tEntry.start + i * duration,
                                duration: duration,
                                originalStart: tEntry.start,
                                originalDuration: duration,
                                originalRepeat: tEntry.repeat,
                                patternId: tEntry.patternId,
                                patternComment: pDef.comment || "",
                                contextComment: tEntry.comment || ""
                            });
                        }
                    }
                } else if (instrument.patterns) {
                    // Old format: maintain backwards compatibility
                    for (const p of instrument.patterns) {
                        for (let i = 0; i < p.repeat; i++) {
                            events.push({
                                start: p.start + i * p.duration,
                                duration: p.duration,
                                originalStart: p.start,
                                originalDuration: p.duration,
                                originalRepeat: p.repeat,
                                patternComment: "",
                                contextComment: p.comment || ""
                            });
                        }
                    }
                }
                events.sort((a, b) => a.start - b.start);

                let cursor = 0;
                for (const e of events) {
                    if (e.start > cursor) {
                        const silence = document.createElement("div");
                        silence.className = "silence";
                        const size = (e.start - cursor) * pxPerUnit + "px";
                        if (isDesktop) {
                            silence.style.width = size;
                        } else {
                            silence.style.height = size;
                        }
                        patternsDiv.appendChild(silence);
                    }
                    const block = document.createElement("div");
                    block.className = "pattern";
                    const size = e.duration * pxPerUnit + "px";
                    if (isDesktop) {
                        block.style.width = size;
                    } else {
                        block.style.height = size;
                    }

                    // Store pattern info for popover
                    block.dataset.start = e.originalStart;
                    block.dataset.duration = e.originalDuration;
                    block.dataset.repeat = e.originalRepeat;
                    block.dataset.patternId = e.patternId || "";
                    block.dataset.patternComment = e.patternComment || "";
                    block.dataset.contextComment = e.contextComment || "";

                    patternsDiv.appendChild(block);
                    cursor = e.start + e.duration;
                }

                col.appendChild(patternsDiv);
                songDiv.appendChild(col);
            }

            songEl.appendChild(songDiv);

            // Setup popover interactions
            setupPopover(isDesktop);
        }

        function setupPopover(isDesktop) {
            const popover = document.getElementById("popover");
            const patterns = document.querySelectorAll(".pattern");

            function showPopover(pattern, event) {
                const start = pattern.dataset.start;
                const duration = pattern.dataset.duration;
                const repeat = pattern.dataset.repeat;
                const patternId = pattern.dataset.patternId;
                const patternComment = pattern.dataset.patternComment;
                const contextComment = pattern.dataset.contextComment;

                let html = '';

                // Show pattern ID if available (new format)
                if (patternId) {
                    html += `<div>Pattern ID: ${patternId}</div>`;
                }

                html += `
                    <div>Start: ${start}</div>
                    <div>Duration: ${duration}</div>
                    <div>Repeat: ${repeat}</div>
                `;

                // Show pattern comment if available
                if (patternComment) {
                    html += `<div>Pattern: ${patternComment}</div>`;
                }

                // Show context comment if available
                if (contextComment) {
                    html += `<div>Context: ${contextComment}</div>`;
                }

                popover.innerHTML = html;
                popover.style.display = "block";

                if (isDesktop) {
                    // Position near cursor (bottom-left corner with margin)
                    popover.style.left = "16px";
                    popover.style.bottom = "16px";
                    popover.style.top = "auto";
                    popover.style.right = "auto";
                } else {
                    // Position at bottom with full width
                    popover.style.left = "16px";
                    popover.style.right = "16px";
                    popover.style.bottom = "16px";
                    popover.style.top = "auto";
                }
            }

            function hidePopover() {
                popover.style.display = "none";
            }

            patterns.forEach(pattern => {
                if (isDesktop) {
                    // Desktop: hover
                    pattern.addEventListener("mouseenter", (e) => showPopover(pattern, e));
                    pattern.addEventListener("mouseleave", hidePopover);
                } else {
                    // Mobile: tap
                    pattern.addEventListener("click", (e) => {
                        e.stopPropagation();
                        if (popover.style.display === "block") {
                            hidePopover();
                        } else {
                            showPopover(pattern, e);
                        }
                    });
                }
            });

            // Close popover when clicking outside on mobile
            if (!isDesktop) {
                document.addEventListener("click", (e) => {
                    if (!e.target.classList.contains("pattern")) {
                        hidePopover();
                    }
                });
            }
        }
    </script>
</body>
</html>
