<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Song</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <a href="index.html">← Accueil</a>
    <h1 id="title"></h1>
    <div id="song"></div>
    <div id="popover" class="popover"></div>

    <script>
        const songId = new URLSearchParams(window.location.search).get("song");
        if (!songId) {
            document.getElementById("title").textContent = "Aucun morceau sélectionné";
        } else {
            fetch(`data/${songId}.json`)
                .then(res => res.json())
                .then(data => {
                    document.title = data.title;

                    // Display title and metadata
                    const titleEl = document.getElementById("title");
                    titleEl.textContent = data.title;

                    // Add metadata if available
                    const metadata = [];
                    if (data.artist) metadata.push(data.artist);
                    if (data.project) metadata.push(data.project);
                    if (data.bpm) metadata.push(`${data.bpm} BPM`);
                    if (data.length) metadata.push(data.length);

                    if (metadata.length > 0) {
                        const metaEl = document.createElement("div");
                        metaEl.style.fontSize = "0.8em";
                        metaEl.style.color = "#666";
                        metaEl.style.marginTop = "8px";
                        metaEl.textContent = metadata.join(" • ");
                        titleEl.parentNode.insertBefore(metaEl, titleEl.nextSibling);
                    }

                    render(data);
                });
        }

        function render(data) {
            // Find total duration across all instruments
            let totalDuration = 0;
            for (const instrument of data.instruments) {
                for (const tEntry of instrument.timeline) {
                    // Find pattern definition to get duration
                    const pDef = instrument.patternDefinitions.find(p => p.id === tEntry.patternId);
                    if (!pDef) continue;

                    const duration = tEntry.duration !== undefined ? tEntry.duration : pDef.duration;
                    const end = tEntry.start + duration * tEntry.repeat;
                    if (end > totalDuration) totalDuration = end;
                }
            }
            if (totalDuration === 0) return;

            // Detect if we're in desktop mode (horizontal layout)
            const isDesktop = window.innerWidth >= 800;
            const songEl = document.getElementById("song");

            let pxPerUnit;
            if (isDesktop) {
                // Horizontal mode: use available width
                const availableWidth = window.innerWidth - 48 - 100 - 16; // padding + label + gap
                pxPerUnit = availableWidth / totalDuration;
            } else {
                // Vertical mode: use available height
                const instrumentNameHeight = 28; // font-size 12px + padding 4px*2 + margin
                const availableHeight = window.innerHeight - songEl.getBoundingClientRect().top - instrumentNameHeight;
                pxPerUnit = availableHeight / totalDuration;
            }

            const songDiv = document.createElement("div");
            songDiv.className = "song";

            for (const instrument of data.instruments) {
                const col = document.createElement("div");
                col.className = "instrument";

                const name = document.createElement("div");
                name.className = "instrument-name";
                name.textContent = instrument.name;
                col.appendChild(name);

                const patternsDiv = document.createElement("div");
                patternsDiv.className = "patterns";

                const events = [];

                // Build a map of pattern definitions
                const patternMap = {};
                for (const pDef of instrument.patternDefinitions) {
                    patternMap[pDef.id] = pDef;
                }

                // Process timeline entries
                for (const tEntry of instrument.timeline) {
                    const pDef = patternMap[tEntry.patternId];
                    if (!pDef) continue; // Skip if pattern not found

                    // Use timeline duration if provided, otherwise use pattern definition duration
                    const duration = tEntry.duration !== undefined ? tEntry.duration : pDef.duration;

                    for (let i = 0; i < tEntry.repeat; i++) {
                        events.push({
                            start: tEntry.start + i * duration,
                            duration: duration,
                            isTimelineStart: i === 0,
                            originalStart: tEntry.start,
                            originalDuration: duration,
                            originalRepeat: tEntry.repeat,
                            patternId: tEntry.patternId,
                            patternComment: pDef.comment || "",
                            contextComment: tEntry.comment || ""
                        });
                    }
                }
                events.sort((a, b) => a.start - b.start);

                let cursor = 0;
                for (const e of events) {
                    if (e.start > cursor) {
                        const silence = document.createElement("div");
                        silence.className = "silence";
                        const size = (e.start - cursor) * pxPerUnit + "px";
                        if (isDesktop) {
                            silence.style.width = size;
                        } else {
                            silence.style.height = size;
                        }
                        patternsDiv.appendChild(silence);
                    }
                    const block = document.createElement("div");
                    block.className = "pattern" + (e.isTimelineStart ? " timeline-start" : "");
                    const size = e.duration * pxPerUnit + "px";
                    if (isDesktop) {
                        block.style.width = size;
                    } else {
                        block.style.height = size;
                    }

                    // Store pattern info for popover
                    block.dataset.start = e.originalStart;
                    block.dataset.duration = e.originalDuration;
                    block.dataset.repeat = e.originalRepeat;
                    block.dataset.patternId = e.patternId || "";
                    block.dataset.patternComment = e.patternComment || "";
                    block.dataset.contextComment = e.contextComment || "";
                    block.dataset.timelineKey = instrument.name + ":" + e.originalStart + ":" + e.patternId;

                    patternsDiv.appendChild(block);
                    cursor = e.start + e.duration;
                }

                col.appendChild(patternsDiv);
                songDiv.appendChild(col);
            }

            songEl.appendChild(songDiv);

            // Setup popover interactions
            setupPopover(isDesktop);
        }

        function setupPopover(isDesktop) {
            const popover = document.getElementById("popover");
            const patterns = document.querySelectorAll(".pattern");

            function highlightTimeline(key) {
                document.querySelectorAll(`.pattern[data-timeline-key="${key}"]`).forEach(el => el.classList.add("active"));
            }

            function clearHighlight() {
                document.querySelectorAll(".pattern.active").forEach(el => el.classList.remove("active"));
            }

            function showPopover(pattern, event) {
                clearHighlight();
                highlightTimeline(pattern.dataset.timelineKey);

                const start = pattern.dataset.start;
                const duration = pattern.dataset.duration;
                const repeat = pattern.dataset.repeat;
                const patternId = pattern.dataset.patternId;
                const patternComment = pattern.dataset.patternComment;
                const contextComment = pattern.dataset.contextComment;

                let html = '';
                if (patternId) {
                    html += `<div>Pattern ID: ${patternId}</div>`;
                }
                html += `
                    <div>Start: ${start}</div>
                    <div>Duration: ${duration}</div>
                    <div>Repeat: ${repeat}</div>
                `;
                if (patternComment) {
                    html += `<div>Pattern: ${patternComment}</div>`;
                }
                if (contextComment) {
                    html += `<div>Context: ${contextComment}</div>`;
                }

                popover.innerHTML = html;
                popover.style.display = "block";

                if (isDesktop) {
                    popover.style.left = "16px";
                    popover.style.bottom = "16px";
                    popover.style.top = "auto";
                    popover.style.right = "auto";
                } else {
                    popover.style.left = "16px";
                    popover.style.right = "16px";
                    popover.style.bottom = "16px";
                    popover.style.top = "auto";
                }
            }

            function hidePopover() {
                popover.style.display = "none";
                clearHighlight();
            }

            patterns.forEach(pattern => {
                if (isDesktop) {
                    pattern.addEventListener("mouseenter", (e) => showPopover(pattern, e));
                    pattern.addEventListener("mouseleave", hidePopover);
                } else {
                    pattern.addEventListener("click", (e) => {
                        e.stopPropagation();
                        if (popover.style.display === "block" && pattern.classList.contains("active")) {
                            hidePopover();
                        } else {
                            showPopover(pattern, e);
                        }
                    });
                }
            });

            if (!isDesktop) {
                document.addEventListener("click", (e) => {
                    if (!e.target.classList.contains("pattern")) {
                        hidePopover();
                    }
                });
            }
        }
    </script>
</body>
</html>
